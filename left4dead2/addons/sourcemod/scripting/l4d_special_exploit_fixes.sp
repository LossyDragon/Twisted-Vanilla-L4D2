#pragma semicolon 1
#pragma newdecls required

#include <sourcemod>
#include <sdktools>
#include <geoip> // v.2 is supported too

#define PLUGIN_VERSION "1.0"

#define CVAR_FLAGS			FCVAR_NOTIFY

public Plugin myinfo = 
{
    name        = "[L4D & L4D2] Special Exploit Fixes",
    author      = "Dragokas",
    description = "Preventing afk & kill cheats and other exploits",
    version     = PLUGIN_VERSION,
    url         = "https://github.com/dragokas/"
};

/*
	Credits: Lux, dr. lex
*/

bool 	g_bRoundStart,
		g_bLeft4dead2;
ConVar 	g_CvarMaxPlayers,
		g_CvarHostName,
		g_hConVarAllBotsTeam,
		g_hCvarHostIp,
		g_hCvarHostPort,
		g_hCvarFallTransportBugFix,
		g_hCvarSteamGroupHide,
		g_hCvarStatusHideSteamId,
		g_hCvarStatusTimeout,
		g_hCvarGoAwayProtect,
		g_hCvarAfkProtect,
		g_hCvarAfkWitchStartle,
		g_hCvarAfkWitchTimeout,
		g_hCvarAfkDead,
		g_hCvarAfkIncap,
		g_hCvarAfkPinned,
		g_hCvarAfkGround,
		g_hCvarAfkVomit,
		g_hCvarAfkVomitTimeout,
		g_hCvarAfkReload,
		g_hCvarAfkPanic,
		g_hCvarAfkPanicTimeout,
		g_hCvarAfkStagger,
		g_hCvarAfkHeal,
		g_hCvarAfkDefib,
		g_hCvarAfkDefibTimeout,
		g_hCvarKillProtect,
		g_hCvarAfkAlias,
		g_hCvarJoinSurAlias,
		g_hCvarJoinInfAlias,
		g_hCvarKillAlias,
		g_hCvarAllPlayersIdle,
		g_hCvarHideNotify;
int 	g_iLastTime[MAXPLAYERS+1];
bool 	g_bPanic[MAXPLAYERS+1],
		g_bWitchStartle[MAXPLAYERS+1],
		g_bGeoIpV2;
float 	g_fDefibTime[MAXPLAYERS+1],
		g_fRoundStartTime,
		g_fSafeRoomOrigin[3],
		g_fSafeRoomMaxs[3],
		g_fSafeRoomMins[3];
char 	g_sMap[64];

char DELIM[] = "\x1D";
const int ENTITY_WORLD = 0;

public APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max)
{
	EngineVersion test = GetEngineVersion();
	g_bLeft4dead2 = (test == Engine_Left4Dead2);
	if( late )
	{
		g_bRoundStart = true;
	}
	MarkNativeAsOptional("GeoipCity");
	MarkNativeAsOptional("GeoipRegion");
	return APLRes_Success;
}

public void OnPluginStart()
{
	LoadTranslations("spec_exploit_fix.phrases");
	
	CreateConVar("l4d_spec_exploit_fix", PLUGIN_VERSION, "Plugin version", FCVAR_NOTIFY | FCVAR_DONTRECORD);
	
	g_hCvarFallTransportBugFix = 	CreateConVar("l4d_sef_fall_transport_fix", 	"1", 	"Fix bug when players falling through the transport in finale? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarSteamGroupHide = 		CreateConVar("l4d_sef_steam_group_hide", 	"1", 	"Make sv_steamgroup ConVar to be publicly invisible? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarStatusHideSteamId = 		CreateConVar("l4d_sef_status_hide_steamid", "1", 	"Hide SteamId in status command for non-admins, redirecting it to status2? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarStatusTimeout = 			CreateConVar("l4d_sef_status_timeout", 		"30", 	"Minimum time to use status2 command again", CVAR_FLAGS);
	g_hCvarGoAwayProtect = 			CreateConVar("l4d_sef_go_away_protect", 	"1", 	"Protect from go away cheats (same way as afk cheats)? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkProtect = 			CreateConVar("l4d_sef_afk_protect", 		"1", 	"Protect from afk cheats? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkWitchStartle = 		CreateConVar("l4d_sef_afk_witch_startle", 	"1", 	"Prevent afk if player startled the witch? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkWitchTimeout = 		CreateConVar("l4d_sef_afk_witch_timeout", 	"60", 	"Delay while afk cannot be used after player startled the witch", CVAR_FLAGS);
	g_hCvarAfkDead = 				CreateConVar("l4d_sef_afk_alive", 			"1", 	"Prevent afk if player dead? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkIncap = 				CreateConVar("l4d_sef_afk_incap", 			"1", 	"Prevent afk if player incapped? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkPinned = 				CreateConVar("l4d_sef_afk_pinned", 			"1", 	"Prevent afk if player pinned by infected? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkGround = 				CreateConVar("l4d_sef_afk_ground", 			"1", 	"Prevent afk if player isn't stay on the ground? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkVomit = 				CreateConVar("l4d_sef_afk_vomit", 			"1", 	"Prevent afk if player vomited? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkVomitTimeout =		CreateConVar("l4d_sef_afk_vomit_timeout", 	"14", 	"Delay while afk cannot be used after player got vomited", CVAR_FLAGS);
	g_hCvarAfkReload = 				CreateConVar("l4d_sef_afk_reload", 			"1", 	"Prevent afk if player reloading the gun? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkPanic = 				CreateConVar("l4d_sef_afk_panic", 			"1", 	"Prevent afk if player started the panic event? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkPanicTimeout = 		CreateConVar("l4d_sef_afk_panic_timeout", 	"60", 	"Delay while afk cannot be used after player started the panic", CVAR_FLAGS);
	g_hCvarAfkStagger = 			CreateConVar("l4d_sef_afk_stagger", 		"1", 	"Prevent afk if player staggered? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkHeal = 				CreateConVar("l4d_sef_afk_heal", 			"1", 	"Prevent afk if somebody healing the player? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkDefib = 				CreateConVar("l4d_sef_afk_defib", 			"1", 	"Prevent afk if somebody defibbed the player? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkDefibTimeout = 		CreateConVar("l4d_sef_afk_defib_timeout", 	"15", 	"Delay while afk cannot be used after somebody defibbed the player", CVAR_FLAGS);
	g_hCvarKillProtect = 			CreateConVar("l4d_sef_kill_protect", 		"1", 	"Protect from kill cheats? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAfkAlias = 				CreateConVar("l4d_sef_afk_alias", 			"0", 	"Add aliases for afk? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarJoinSurAlias = 			CreateConVar("l4d_sef_join_sur_alias", 		"0", 	"Add aliases for join survivor team? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarJoinInfAlias = 			CreateConVar("l4d_sef_join_inf_alias", 		"0", 	"Add aliases for join infected team? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarKillAlias = 				CreateConVar("l4d_sef_kill_alias", 			"0", 	"Add aliases for selfkill? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarAllPlayersIdle = 		CreateConVar("l4d_sef_all_players_idle_fix","0", 	"Fix all players idle while joining the server? (0 - No, 1 - Yes)", CVAR_FLAGS);
	g_hCvarHideNotify = 			CreateConVar("l4d_sef_notify_hide", 		"0", 	"Hide change notification of some ConVars? (0 - No, 1 - Yes)", CVAR_FLAGS);
	
	AutoExecConfig(true, "l4d_spec_exploit_fix");
	
	g_CvarHostName = FindConVar("hostname");
	g_CvarMaxPlayers = FindConVar("sv_maxplayers");
	if( g_CvarMaxPlayers == null )
	{
		g_CvarMaxPlayers = FindConVar("sv_visiblemaxplayers");
	}
	g_hConVarAllBotsTeam = FindConVar("sb_all_bot_team");
	g_hCvarHostIp = FindConVar("hostip");
	g_hCvarHostPort = FindConVar("hostport");
	
	HookEvent("server_cvar", 			Event_ServerCvar, 	EventHookMode_Pre);
	HookEvent("player_disconnect", 		Event_PlayerDisconnect, EventHookMode_Pre);
	HookEvent("create_panic_event", 	Event_Panic);
	HookEvent("witch_harasser_set", 	Event_WitchHarraser);
	HookEvent("witch_killed", 			Event_WitchKilled);
	HookEvent("player_spawn", 			Event_PlayerSpawn);
	HookEvent("round_start", 			Event_RoundStart,	EventHookMode_PostNoCopy);
	HookEvent("round_end", 				Event_RoundEnd,		EventHookMode_PostNoCopy);
	HookEvent("mission_lost", 			Event_RoundEnd,		EventHookMode_PostNoCopy);
	HookEvent("map_transition", 		Event_RoundEnd,		EventHookMode_PostNoCopy);
	HookEvent("finale_vehicle_leaving", Event_FinaleVehicleLeaving, EventHookMode_PostNoCopy);
	
	if( g_bLeft4dead2 )
	{
		HookEvent("defibrillator_used", Event_DefibUsed);
	}
	
	AddCommandListener(BlockChicken, "spec_goto"); // block exploit
	RegConsoleCmd("sm_tntstart", DummyCmd); // block multimedia keyboard incident hotkey
	
	RegConsoleCmd("status2", CmdStatus, "Status command v2");
	AddCommandListener(ShowStatus, "status");
	
	AddCommandListener(Listen_Keyboard, "go_away_from_keyboard");
	
	AddCommandListener(BlockAfk, "sm_afk");
	AddCommandListener(BlockAfk, "sm_away");
	AddCommandListener(BlockAfk, "sm_idle");
	AddCommandListener(BlockAfk, "sm_spectate");
	AddCommandListener(BlockAfk, "sm_spectators");
	AddCommandListener(BlockAfk, "sm_joinspectators");
	AddCommandListener(BlockAfk, "sm_jointeam1");
	
	AddCommandListener(Listen_Kill, "sm_kill");
	AddCommandListener(Listen_Kill, "sm_suicide");
}

public void OnAutoConfigsBuffered()
{
	RequestFrame(OnFrameRegCmd);
}

public void OnConfigsExecuted()
{
	if( g_hCvarHideNotify.BoolValue )
	{
		FindConVar("director_no_survivor_bots").Flags &= ~FCVAR_NOTIFY;
		FindConVar("sv_cheats").Flags &= ~FCVAR_NOTIFY;
	}
}

public void OnAllPluginsLoaded()
{	
	g_bGeoIpV2 = ( FeatureStatus_Available == GetFeatureStatus(FeatureType_Native, "GeoipTimezone") );
}

public void OnFrameRegCmd()
{
	static bool b_AfkAlias, b_JoinSurAlias, b_JoinInfAlias, b_KillAlias;
	
	if( g_hCvarAfkAlias.BoolValue )
	{
		if( !b_AfkAlias )
		{
			char cmds[] = { "sm_afk", "sm_away", "sm_idle", "sm_spectate", "sm_spectators", "sm_spectator", "sm_joinspectators", "sm_jointeam1" };
			for( int i = 0; i <= sizeof(cmds); i++ )
			{
				if( !CommandExists(cmds[i]) )
					RegConsoleCmd(cmds[i], AFKTurnClientToSpectate);
			}
			b_AfkAlias = true;
		}
	}
	
	if( g_hCvarJoinSurAlias.BoolValue )
	{
		if( !b_JoinSurAlias )
		{
			char cmds[] = { "sm_survivors", "sm_joinsurvivors", "sm_jointeam2" /*, "sm_join"*/ };
			for( int i = 0; i <= sizeof(cmds); i++ )
			{
				if( !CommandExists(cmds[i]) )
					RegConsoleCmd(cmds[i], AFKTurnClientToSurvivors);
			}
			b_JoinSurAlias = true;
		}
	}
	
	if( g_hCvarJoinInfAlias.BoolValue )
	{
		if( b_JoinInfAlias )
		{
			char cmds[] = { "sm_infected", "sm_joininfected", "sm_jointeam3" };
			for( int i = 0; i <= sizeof(cmds); i++ )
			{
				if( !CommandExists(cmds[i]) )
					RegConsoleCmd(cmds[i], AFKTurnClientToInfected);
			}
			b_JoinInfAlias = true;
		}
	}
	
	if( g_hCvarKillAlias.BoolValue )
	{
		if( b_KillAlias )
		{
			char cmds[] = { "sm_kill", "sm_suicide" };
			for( int i = 0; i <= sizeof(cmds); i++ )
			{
				if( !CommandExists(cmds[i]) )
					RegConsoleCmd(cmds[i], Cmd_Kill);
			}
			b_KillAlias = true;
		}
	}
}

public Action Listen_Kill(int client, const char[] sCommand, int iArg)
{
	if( !g_hCvarKillProtect.BoolValue )
		return Plugin_Continue;
	
	if( IsClientInGame(client) )
	{
		if( IsInSafeRoom(client) )
		{
			PrintToChat(client, "%t", "kill_saferoom"); // [Kill] You cannot die in saferoom!
			return Plugin_Stop;
		}
		if( !g_bRoundStart )
		{
			PrintToChat(client, "%t", "kill_round_end"); // [Kill] You cannot die when round ends!
			return Plugin_Stop;
		}
		ForcePlayerSuicide(client);
	}
	return Plugin_Stop;
}

public Action Cmd_Kill(int client, int args)
{
	if( g_hCvarKillProtect.BoolValue )
	{	
		if( IsClientInGame(client) )
		{
			if( IsInSafeRoom(client) )
			{
				PrintToChat(client, "%t", "kill_saferoom"); // [Kill] You cannot die in saferoom!
				return Plugin_Handled;
			}
			if( !g_bRoundStart )
			{
				PrintToChat(client, "%t", "kill_round_end"); // [Kill] You cannot die when round ends!
				return Plugin_Handled;
			}
		}
	}
	ForcePlayerSuicide(client);
	return Plugin_Handled;
}

public Action AFKTurnClientToSpectate(int client, int argCount)
{
	if( IsClientInGame(client) && IsAllowAFK(client) )
	{
		ChangeClientTeam(client, 1);
	}
	return Plugin_Handled;
}

public Action AFKTurnClientToSurvivors(int client, int args)
{ 
	if( IsClientInGame(client) )
	{
		ClientCommand(client, "jointeam 2");
	}
	return Plugin_Handled;
}
public Action AFKTurnClientToInfected(int client, int args)
{
	if( IsClientInGame(client) )
	{
		ClientCommand(client, "jointeam 3");
	}
	return Plugin_Handled;
}

Action DummyCmd(int client, int args)
{
	return Plugin_Handled;
}

// Preventing "Kicked by console: All players idle"
public void OnClientPutInServer(int client)
{
	if( g_hCvarAllPlayersIdle.BoolValue )
	{
		if( !IsFakeClient(client) )
		{
			if( g_hConVarAllBotsTeam.IntValue != 1 )
			{
				g_hConVarAllBotsTeam.SetInt(1);
			}
		}
	}
}

public Action Event_DefibUsed(Event hEvent, const char[] name, bool dontBroadcast) 
{
    int subject = GetClientOfUserId(GetEventInt(hEvent, "subject"));
    g_fDefibTime[subject] = GetEngineTime();
}

public void Event_RoundStart(Event event, const char[] name, bool dontBroadcast)
{
	g_fRoundStartTime = GetGameTime();
	g_bRoundStart = true;
}

public void Event_PlayerSpawn(Event event, const char[] name, bool dontBroadcast)
{
	int client = GetClientOfUserId(event.GetInt("userid"));
	g_bPanic[client] = false;
	g_bWitchStartle[client] = false;
}

public void Event_WitchHarraser(Event event, const char[] name, bool dontBroadcast)
{
	int client = GetClientOfUserId(event.GetInt("userid"));
	
	if( client && GetClientTeam(client) == 2 && !IsFakeClient(client) )
	{
		g_bWitchStartle[client] = true;
		CreateTimer(g_hCvarAfkWitchTimeout.FloatValue, Timer_AllowWitchAfk, GetClientUserId(client), TIMER_FLAG_NO_MAPCHANGE);
	}
}

public void Event_WitchKilled(Event event, const char[] name, bool dontBroadcast)
{
	int client = GetClientOfUserId(event.GetInt("userid"));
	
	if( client && IsClientInGame(client) )
	{
		g_bWitchStartle[client] = false;
	}
}

public Action Timer_AllowWitchAfk(Handle timer, int UserId)
{
	int client = GetClientOfUserId(UserId);
	g_bWitchStartle[client] = false;
}

public void Event_Panic(Event event, const char[] name, bool dontBroadcast)
{
	int client = GetClientOfUserId(event.GetInt("userid"));
	
	if( client && GetClientTeam(client) == 2 && !IsFakeClient(client) )
	{
		g_bPanic[client] = true;
		CreateTimer(g_hCvarAfkPanicTimeout.FloatValue, Timer_AllowAfk, GetClientUserId(client), TIMER_FLAG_NO_MAPCHANGE);
	}
}

Action Timer_AllowAfk(Handle timer, int UserId)
{
	int client = GetClientOfUserId(UserId);
	g_bPanic[client] = false;
}

public void Event_PlayerDisconnect(Event event, const char[] name, bool dontBroadcast)
{
	if( g_hCvarAllPlayersIdle.BoolValue )
	{
		int client = GetClientOfUserId(event.GetInt("userid"));
		
		if( client && !IsFakeClient(client) && !RealPlayerExist(client) )
		{
			g_hConVarAllBotsTeam.SetInt(0);
		}
	}
}

bool RealPlayerExist(int iExclude = 0)
{
	for( int i = 1; i < MaxClients; i++ )
	{
		if( i != iExclude && IsClientConnected(i) )
		{
			if( !IsFakeClient(i) )
			{
				return true;
			}
		}
	}
	return false;
}

public void Event_ServerCvar(Event event, const char[] name, bool dontBroadcast)
{
	if( !g_hCvarSteamGroupHide.BoolValue )
		return;
	
	int cvar = GetClientOfUserId(event.GetInt("cvarname"));
	cvar &= ~FCVAR_NOTIFY;
	/*
	if (StrEqual(name, "sv_steamgroup", false)) {
		ConVar cv = FindConVar("sv_steamgroup");
		if (cv != null)
			cv.Flags &= ~FCVAR_NOTIFY;
		
	}
	*/
	SetCommandFlags("sv_steamgroup", cvar);
}

public void Event_FinaleVehicleLeaving(Handle event, const char[] name, bool dontBroadcast)
{
	if( !g_hCvarFallTransportBugFix.BoolValue )
		return;
	
	int entity = FindEntityByClassname(-1, "info_survivor_position");
	if( entity != -1 )
	{
		float pos[3];
		GetEntPropVector(entity, Prop_Send, "m_vecOrigin", pos);
		
		for( int i = 1; i <= MaxClients; i++ )
		{
			if( IsClientInGame(i) && GetClientTeam(i) == 2 && IsPlayerAlive(i) )
			{
				if( GetEntProp(i, Prop_Send, "m_isIncapacitated", 1) != 1 ) // why? Ok, we don't take the wounded ^^
				{
					TeleportEntity(i, pos, NULL_VECTOR, NULL_VECTOR);
				}
			}
		}
	}
}

public Action CmdStatus(int client, int args)
{
	if (client == 0 || !IsClientInGame(client))
		return Plugin_Handled;
	
	bool bAdmin = IsClientRootAdmin(client);
	
	if( !bAdmin && g_iLastTime[client] != 0 )
	{
		if( g_iLastTime[client] + g_hCvarStatusTimeout.IntValue > GetTime() )
		{
			PrintToConsole(client, "Wait %i sec.", g_hCvarStatusTimeout.IntValue - (GetTime() - g_iLastTime[client]));
			return Plugin_Handled;
		}
	}
	g_iLastTime[client] = GetTime();
	
	int players, bots, max;
	
	for( int i = 1; i <= MaxClients; i++ )
	{
		if( IsClientInGame(i) )
		{
			if( IsFakeClient(i) )
			{
				if( GetClientTeam(i) == 2 )
					bots++;
			}
			else {
				players++;
			}
		}
	}
	
	char NetIP[64];
	int pieces[4], port;
	int longip = g_hCvarHostIp.IntValue;
	port = g_hCvarHostPort.IntValue;

	pieces[0] = (longip >> 24) & 0x000000FF; // thanks to SideX
	pieces[1] = (longip >> 16) & 0x000000FF; 
	pieces[2] = (longip >> 8) & 0x000000FF; 
	pieces[3] = longip & 0x000000FF; 

	FormatEx(NetIP, sizeof(NetIP), "%d.%d.%d.%d", pieces[0], pieces[1], pieces[2], pieces[3]);  
	
	static char s[64], sMsg[1024];
	max = g_CvarMaxPlayers.IntValue;
	g_CvarHostName.GetString(s, sizeof(s));
	FormatEx(sMsg, sizeof(sMsg), "hostname: %s", s);
	
	StrCat(sMsg, sizeof(sMsg), "\nversion : 1.0.3.8");
	Format(sMsg, sizeof(sMsg), "%s\nip      : %s:%i", sMsg, NetIP, port);
	
	GetCurrentMap(s, sizeof(s));
	Format(sMsg, sizeof(sMsg), "%s\nmap     : %s", sMsg, s);
	Format(sMsg, sizeof(sMsg), "%s\nplayers : %i humans, %i bots (%i max)\n", sMsg, players, bots, max);
	
	if( bAdmin )
	{
		StrCat(sMsg, sizeof(sMsg), "\n# name userid ping");
	}
	else {
		StrCat(sMsg, sizeof(sMsg), "\n# name ping");
	}
	
	//PrintToConsole(client, sMsg);
	//sMsg[0] = '\0';
	StrCat(sMsg, sizeof sMsg, DELIM);
	
	float ping;
	bool bObserver;
	int n;
	static char sSteamId[64];
	static char ip[16];
	static char country[64];
	static char city[64];
	static char region[64];
	
	for( int i = 1; i <= MaxClients; i++ )
	{
		if( IsClientInGame(i) && !(IsFakeClient(i) && GetClientTeam(i) == 3) )
		{
			if( n % 6 == 0 ) // split buffer because of console print limit
			{
				//PrintToConsole(client, sMsg);
				//sMsg[0] = '\0';
				StrCat(sMsg, sizeof sMsg, DELIM);
			}
			
			n++;
			if( IsFakeClient(i) )
			{
				if (bAdmin)
				{
					Format(sMsg, sizeof(sMsg), "%s\n# %i - %-5i \"%N\" (bot)", sMsg, n, GetClientUserId(i), i);
				}
				else {
					Format(sMsg, sizeof(sMsg), "%s\n# %i - \"%N\" (bot)", sMsg, n, i);
				}
			}
			else {
				ping = GetClientAvgLatency(i, NetFlow_Outgoing) * 1024;
				bObserver = IsClientObserver(i);
				
				if( bAdmin )
				{
					GetClientAuthId(i, AuthId_Steam2, sSteamId, sizeof(sSteamId));
					GetClientIP(i, ip, sizeof(ip));
					GeoipCountry(ip, country, sizeof(country));
					
					#if !defined _geoip_included // geoip v2 doesn't have a define
					
						//if( GetFeatureStatus(FeatureType_Native, "GeoipCity") == FeatureStatus_Available )
						//if( GetFeatureStatus(FeatureType_Native, "GeoipRegion") == FeatureStatus_Available )
						if( g_bGeoIpV2 )
						{
							GeoipCity(ip, city, sizeof(city));
							GeoipRegion(ip, region, sizeof(region));
						}
					#endif
					
					Format(sMsg, sizeof(sMsg), "%s\n# %i - %-5i \"%N\" [%s] (%s, %s, %s) : %.0f ms. %s", 
						sMsg, n, GetClientUserId(i), i, sSteamId, country, city, region, ping, bObserver ? "(observer)" : "");
				}
				else {
					Format(sMsg, sizeof(sMsg), "%s\n# %i - \"%N\" : %.0f ms. %s", sMsg, n, i, ping, bObserver ? "(observer)" : "");
				}
			}
		}
	}
	PrintToConsoleFramed(client, sMsg); // prevents torn lines
	return Plugin_Handled;
}

void PrintToConsoleFramed(int client, char[] msg)
{
	DataPack dp = new DataPack();
	dp.WriteCell(0);
	dp.WriteCell(GetClientUserId(client));
	dp.WriteString(msg);
	RequestFrame(OnConsolePrintFrame, dp);
}

public void OnConsolePrintFrame(DataPack dp)
{
	static char msg[1024];
	dp.Reset();
	int pos = dp.ReadCell();
	int client = GetClientOfUserId(dp.ReadCell());
	if( !client || !IsClientInGame(client) )
	{
		delete dp;
		return;
	}
	dp.ReadString(msg, sizeof msg);
	int sep = StrContains(msg[pos], DELIM, true);
	if( sep != -1 )
	{
		msg[pos + sep] = '\0';
	}
	PrintToConsole(client, msg[pos]);
	if( sep != -1 )
	{
		dp.Reset();
		dp.WriteCell(pos + sep + 2);
		RequestFrame(OnConsolePrintFrame, dp);
	}
	else {
		delete dp;
	}
}

public Action ShowStatus(int client, const char[] sCommand, int iArg)
{
	if( g_hCvarStatusHideSteamId.BoolValue )
	{
		PrintToConsoleAll("%t", "status_deprecated"); // "\"status\" is deprecated. Use \"status2\""
		return Plugin_Stop;
	}
	return Plugin_Continue;
}

stock bool IsClientRootAdmin(int client)
{
	return ((GetUserFlagBits(client) & ADMFLAG_ROOT) != 0);
}

public void Event_RoundEnd(Event event, char[] name, bool dontBroadcast)
{
	g_bRoundStart = false;
}

public Action BlockChicken(int client, const char[] sCommand, int iArg)
{
	return Plugin_Stop;
}

bool IsAllowAFK(int client)
{
	if( client == 0 || !IsClientInGame(client) )
		return true;
	
	if( !IsPlayerAlive(client) && g_hCvarAfkDead.BoolValue )
	{
		PrintToChat(client, "%t", "afk_alive"); // [AFK] You must be alive!
		return false;
	}
	
	if( GetClientTeam(client) == 1 )
	{
		PrintToChat(client, "%t", "afk_team"); // [AFK] You must be in team!
		return false;
	}
	
	if( g_hCvarAfkIncap.BoolValue && GetEntProp(client, Prop_Send, "m_isIncapacitated") != 0 )
	{
		PrintToChat(client, "%t", "afk_incap"); // [AFK] You must be not in incap!
		return false;
	}
	
	if( g_hCvarAfkPinned.BoolValue && IsBeingPwnt(client) )
	{
		PrintToChat(client, "%t", "afk_free"); // [AFK] You must free from infected!
		return false;
	}
	
	if( g_hCvarAfkGround.BoolValue && GetEntPropEnt(client, Prop_Send, "m_hGroundEntity") != ENTITY_WORLD ) // not on ground?
	{
		PrintToChat(client, "%t", "afk_ground"); // [AFK] You must be on the ground!
		return false;
	}
	
	if( g_hCvarAfkVomit.BoolValue )
	{
		static float vomitStart;
		vomitStart = GetEntPropFloat(client, Prop_Send, "m_vomitStart");
		
		if( (vomitStart + g_hCvarAfkVomitTimeout.FloatValue) > GetGameTime() && vomitStart > g_fRoundStartTime)  
		{
			PrintToChat(client, "%t", "afk_vomit"); // [AFK] You must fresh yourself from vomit
			return false;
		}
	}
	
	if( g_hCvarAfkReload.BoolValue )
	{
		static int weapon;
		weapon = GetPlayerWeaponSlot(client, 0);
		if( weapon != -1 )
		{ 
			if( GetEntProp(weapon, Prop_Data, "m_bInReload") ) // Are they reloading?
			{
				PrintToChat(client, "%t", "afk_reload"); // [AFK] You must complete weapon reload!
				return false;
			}
		}
	}

	/* // false positive on map start, possible alternate "m_timestamp"
	float vec[3]; 
	GetEntPropVector(client, Prop_Send, "m_staggerStart", vec); // 
	if (vec[0] != 0.000000 || vec[1] != 0.000000 || vec[2] != 0.000000) 
	{
		PrintToChat(client, "[AFK] You must wait until stagger finishes!");
		return false;
	}
	*/
	
	if( g_bPanic[client] && g_hCvarAfkPanic.BoolValue )
	{
		PrintToChat(client, "%t", "afk_panic"); // [AFK] You must wait until panic finishes!
		return false;
	}
	
	if( g_hCvarAfkStagger.BoolValue )
	{
		static float vec[3];
		GetEntPropVector(client, Prop_Data, "m_vecVelocity", vec);
	
		if( vec[0] != 0.0 || vec[1] != 0.0 || vec[2] != 0.0 ) // against stagger and tank push
		{
			PrintToChat(client, "%t", "afk_nomove"); // [AFK] You must stay still to go afk!
			return false;
		}
	}
	
	if( g_hCvarAfkHeal.BoolValue && IsBeingHealed(client) )
	{
		PrintToChat(client, "%t", "afk_heal"); // [AFK] Can't go afk when being healed!
		return false;
	}

	if( g_bWitchStartle[client] && g_hCvarAfkWitchStartle.BoolValue )
	{
		PrintToChat(client, "%t", "afk_witch"); // [AFK] Can't go afk when startled the witch!
		return false;
	}
	
	if( g_bLeft4dead2 && g_hCvarAfkDefib.BoolValue )
	{
		if( GetEngineTime() - g_fDefibTime[client] < g_hCvarAfkDefibTimeout.FloatValue )
		{
			PrintToChat(client, "%t", "afk_defib"); // [AFK] Not allowed to go idle after being defibbed
		}
	}
	
	return true;
}

public Action BlockCmd(int client, const char[] sCommand, int iArg)
{
	return Plugin_Stop;
}

public Action BlockAfk(int client, const char[] sCommand, int iArg)
{
	if( g_hCvarAfkProtect.BoolValue )
	{
		if( !IsAllowAFK(client) )
		{
			return Plugin_Stop;
		}
	}
	return Plugin_Continue;
}

public Action Listen_Keyboard(int client, const char[] sCommand, int iArg)
{
	if( g_hCvarGoAwayProtect.BoolValue )
	{
		if( !IsAllowAFK(client) )
		{
			return Plugin_Stop;
		}
	}
	return Plugin_Continue;
}

bool IsBeingPwnt(int client)
{
	if( GetEntPropEnt(client, Prop_Send, "m_pounceAttacker") != -1 )
		return true;
	if( GetEntPropEnt(client, Prop_Send, "m_tongueOwner") != -1 )
		return true;
	
	if( g_bLeft4dead2 )
	{
		if( GetEntPropEnt(client, Prop_Send, "m_pummelAttacker") != -1 )
			return true;
		if( GetEntPropEnt(client, Prop_Send, "m_carryAttacker") != -1 )
			return true;
		if( GetEntPropEnt(client, Prop_Send, "m_jockeyAttacker") != -1 )
			return true;
	}
	return false;
}

bool IsBeingHealed(int client)
{
	if( g_bLeft4dead2 )
	{
		return false;
	}
	else {
		return GetEntPropEnt(client, Prop_Send, "m_healOwner") != -1;
	}
}

bool IsInSafeRoom(int client)
{
	float pos[3], min[3], max[3], me[3], maxme[3]; // minme[3], 
	
	pos = g_fSafeRoomOrigin;
	min = g_fSafeRoomMins;
	max = g_fSafeRoomMaxs;
	
	AddVectors(min, pos, min);
	AddVectors(max, pos, max);
	
	GetEntPropVector(client, Prop_Send, "m_vecOrigin", me);
	
	if (strcmp(g_sMap, "l4d_smalltown03_ranchhouse") == 0)
	{
		if (me[0] > -2442.0 && (175.0 < me[2] < 200.0) )
			return false;
	}
	else if (strcmp(g_sMap, "l4d_smalltown04_mainstreet") == 0)
	{
		max[2] += 20.0;
	}
	
	GetEntPropVector(client, Prop_Send, "m_vecMaxs", maxme);
	AddVectors(maxme, me, maxme);
	
	return IsDotInside(me, min, max) && maxme[2] < max[2];
}

bool IsDotInside(float dot[3], float min[3], float max[3])
{
	if(	min[0] < dot[0] < max[0] &&
		min[1] < dot[1] < max[1] &&
		min[2] < dot[2] < max[2] ) {
		return true;
	}
	return false;
}

void GetSaferoom()
{
	int chl = -1;
	chl = FindEntityByClassname(-1, "info_changelevel");
	if( chl == -1 )
	{
		chl = FindEntityByClassname(-1, "trigger_changelevel");
		if( chl == -1 )
			return;
	}

	float min[3], max[3];
	
	GetEntPropVector(chl, Prop_Send, "m_vecMins", min);
	GetEntPropVector(chl, Prop_Send, "m_vecMaxs", max);
	
	// zone expanding by Y-axis
	min[2] -= 15.0;
	max[2] += 40.0;
	
	GetEntPropVector(chl, Prop_Send, "m_vecOrigin", g_fSafeRoomOrigin);
	g_fSafeRoomMins = min;
	g_fSafeRoomMaxs = max;
}

public void OnMapStart()
{
	GetCurrentMap(g_sMap, sizeof(g_sMap));	
	GetSaferoom();
}