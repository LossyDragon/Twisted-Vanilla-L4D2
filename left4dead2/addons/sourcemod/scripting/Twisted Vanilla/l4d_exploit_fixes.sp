#define PLUGIN_VERSION 		"2.1"

/*======================================================================================
	Plugin Info:

*	Name	:	[L4D & L4D2] Various Exploit Fixes
*	Author	:	SilverShot
*	Descrp	:	Prevents exploits that cause Survivors or explosives to take damage from idle, disconnected or team changed players.
*	Link	:	https://forums.alliedmods.net/showthread.php?t=322661
*	Plugins	:	https://sourcemod.net/plugins.php?exact=exact&sortby=title&search=1&author=Silvers

========================================================================================
	Change Log:

2.1 (10-May-2020)
	- Various changes to tidy up code.

2.0 (04-Apr-2020)
	- Added protection against players who change team to exploit increased damage.
	- Added protection against players disconnecting. Thanks to "MasterMind420" for reporting.
	- Added protection against explosives taking damage from delayed explosions. Thanks to "Lux" for reporting.
	- Renamed the plugin to "Various Exploit Fixes". Delete the previous version if you installed.

1.0 (01-Apr-2020)
	- Initial release.

======================================================================================*/

#pragma semicolon 1
#pragma newdecls required

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>

#define MODEL_FIREWORK		"models/props_junk/explosive_box001.mdl"
#define MODEL_GASCAN		"models/props_junk/gascan001a.mdl"
#define MODEL_OXYGEN		"models/props_equipment/oxygentank01.mdl"
#define MODEL_PROPANE		"models/props_junk/propanecanister001a.mdl"


bool g_bLateLoad, g_bLeft4Dead2;
int g_iUserID[MAXPLAYERS+1];
int g_iTeamID[2048];



// ====================================================================================================
//					PLUGIN INFO / START
// ====================================================================================================
public Plugin myinfo =
{
	name = "[L4D & L4D2] Various Exploit Fixes",
	author = "SilverShot",
	description = "Prevents exploits that cause Survivors or explosives to take damage from idle, disconnected or team changed players.",
	version = PLUGIN_VERSION,
	url = "https://forums.alliedmods.net/showthread.php?t=322661"
}

public APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max)
{
	EngineVersion test = GetEngineVersion();

	if( test == Engine_Left4Dead ) g_bLeft4Dead2 = false;
	else if( test == Engine_Left4Dead2 ) g_bLeft4Dead2 = true;
	else
	{
		strcopy(error, err_max, "Plugin only supports Left 4 Dead 1 & 2.");
		return APLRes_SilentFailure;
	}

	g_bLateLoad = late;
	return APLRes_Success;
}

public void OnAllPluginsLoaded()
{
	if( FindConVar("l4d_friendly_fire_idle_fix_version") != null )
	{
		SetFailState("Delete the old \"Friendly Fire Idle Fix\" plugin to run this one.");
	}
}

public void OnPluginStart()
{
	if( g_bLateLoad )
	{
		for( int i = 1; i <= MaxClients; i++ )
		{
			if( IsClientInGame(i) )
			{
				g_iUserID[i] = GetClientUserId(i);
				SDKHook(i, SDKHook_OnTakeDamage, OnTakeDamageSurvivor);
			}
		}

		int entity = -1;
		char modelname[64];
		while( (entity = FindEntityByClassname(entity, "prop_physics")) != INVALID_ENT_REFERENCE )
		{
			GetEntPropString(entity, Prop_Data, "m_ModelName", modelname, sizeof(modelname));
			if( strcmp(modelname, MODEL_OXYGEN) == 0 || strcmp(modelname, MODEL_PROPANE) == 0 || strcmp(modelname, MODEL_GASCAN) == 0 || (g_bLeft4Dead2 && strcmp(modelname, MODEL_FIREWORK) == 0) )
			{
				SDKHook(entity, SDKHook_OnTakeDamage, OnTakeDamageProp);
			}
		}

		// Maybe these shouldn't be monitored from late load, since client could have already disconnected/changed team. Here for reference anyway.
		/*
		entity = -1;
		while( (entity = FindEntityByClassname(entity, "inferno")) != INVALID_ENT_REFERENCE )
		{
			g_iTeamID[entity] = GetOwnerTeam(entity);
		}

		if( g_bLeft4Dead2 )
		{
			entity = -1;
			while( (entity = FindEntityByClassname(entity, "fire_cracker_blast")) != INVALID_ENT_REFERENCE )
			{
				g_iTeamID[entity] = GetOwnerTeam(entity);
			}

			entity = -1;
			while( (entity = FindEntityByClassname(entity, "grenade_launcher_projectile")) != INVALID_ENT_REFERENCE )
			{
				g_iTeamID[entity] = GetOwnerTeam(entity);
			}
		}
		// */
	}

	CreateConVar("l4d_exploit_fixes_version", PLUGIN_VERSION, "Various Exploit Fixes version.", FCVAR_NOTIFY|FCVAR_DONTRECORD);
}

/*
int GetOwnerTeam(int entity)
{
	int client = GetEntPropEnt(entity, Prop_Send, "m_hOwnerEntity");

	if( client && client <= MaxClients && IsClientInGame(client) )
	{
		return GetClientTeam(client);
	}

	return 0;
}
// */



// ====================================================================================================
//					HOOKS
// ====================================================================================================
public void OnClientPutInServer(int client)
{
	SDKHook(client, SDKHook_OnTakeDamage, OnTakeDamageSurvivor);
	g_iUserID[client] = GetClientUserId(client);
}

public void OnEntityCreated(int entity, const char[] classname)
{
	if( entity <= MaxClients || entity >= 2048 ) return;

	g_iTeamID[entity] = 0;

	if( strcmp(classname, "inferno") == 0 || strcmp(classname, "pipe_bomb_projectile") == 0 || (g_bLeft4Dead2 && (strcmp(classname, "fire_cracker_blast") == 0 || strcmp(classname, "grenade_launcher_projectile") == 0)) )
	{
		SDKHook(entity, SDKHook_SpawnPost, OnSpawn);
	}
	else if( strcmp(classname, "physics_prop") == 0 || strcmp(classname, "prop_physics") == 0 )
	{
		SDKHook(entity, SDKHook_SpawnPost, OnSpawnProp);
	}
	else if( strcmp(classname, "prop_fuel_barrel") == 0 )
	{
		SDKHook(entity, SDKHook_OnTakeDamage, OnTakeDamageProp);
	}
}

void OnSpawn(int entity)
{
	int attacker = GetEntPropEnt(entity, Prop_Send, "m_hOwnerEntity");
	if( attacker > 0 && attacker <= MaxClients && IsClientInGame(attacker) )
	{
		g_iTeamID[entity] = GetClientTeam(attacker);
	}
}

void OnSpawnProp(int entity)
{
	static char modelname[64];
	GetEntPropString(entity, Prop_Data, "m_ModelName", modelname, sizeof(modelname));

	if( strcmp(modelname, MODEL_OXYGEN) == 0 || strcmp(modelname, MODEL_PROPANE) == 0 || strcmp(modelname, MODEL_GASCAN) == 0 || (g_bLeft4Dead2 && strcmp(modelname, MODEL_FIREWORK) == 0) )
	{
		SDKHook(entity, SDKHook_OnTakeDamage, OnTakeDamageProp);
	}
}

public Action OnTakeDamageProp(int victim, int &attacker, int &inflictor, float &damage, int &damagetype)
{
	// Block idle/spectators/change team exploit, from team 2/pipe
	if( attacker == inflictor && inflictor > MaxClients && g_iTeamID[inflictor] == 2 )
	{
		attacker = GetEntPropEnt(inflictor, Prop_Send, "m_hOwnerEntity");
		if( attacker == -1 || (attacker > 0 && attacker <= MaxClients && (IsClientInGame(attacker) == false || GetClientUserId(attacker) != g_iUserID[attacker])) )
		{
			return Plugin_Handled;
		}
	}

	// Block disconnected exploit, from team 2/pipe
	else if( attacker > 0 && attacker <= MaxClients )
	{
		if( g_iTeamID[inflictor] == 2 && IsClientInGame(attacker) == false || GetClientUserId(attacker) != g_iUserID[attacker] || GetClientTeam(attacker) != 2 )
		{
			return Plugin_Handled;
		}
	}

	return Plugin_Continue;
}

public Action OnTakeDamageSurvivor(int victim, int &attacker, int &inflictor, float &damage, int &damagetype)
{
	if( attacker > 0 && attacker <= MaxClients && inflictor > MaxClients && (g_iTeamID[inflictor] == 2 || damagetype == 134217792) )
	{
		// Block idle/spectators/change team exploit, from team 2/pipe
		if( GetClientTeam(victim) == 2 && GetClientTeam(attacker) != 2 )
		{
			// weapon_pipe_bomb / weapon_oxygentank. Is verify pipe necessary, does anything else even have the exact same damagetype?
			if( damagetype == 134217792 )
			{
				char classname[5];
				GetEdictClassname(inflictor, classname, sizeof(classname));
				if( strcmp(classname, "pipe") == 0 )
				{
					return Plugin_Handled;
				}
			}
			else
			{
				return Plugin_Handled;
			}
		}
	}

	// Block disconnected exploit, from team 2/pipe
	else if( attacker == inflictor && inflictor > MaxClients && (g_iTeamID[inflictor] == 2 || damagetype == 134217792) && GetClientTeam(victim) == 2 )
	{
		// weapon_pipe_bomb / weapon_oxygentank. Is verify pipe necessary, does anything else even have the exact same damagetype?
		if( damagetype == 134217792 )
		{
			char classname[5];
			GetEdictClassname(inflictor, classname, sizeof(classname));
			if( strcmp(classname, "pipe") == 0 )
			{
				return Plugin_Handled;
			}
		}
		else
		{
			attacker = GetEntPropEnt(inflictor, Prop_Send, "m_hOwnerEntity");
			if( attacker == -1 || (attacker > 0 && attacker <= MaxClients && (IsClientInGame(attacker) == false || GetClientUserId(attacker) != g_iUserID[attacker])) )
			{
				return Plugin_Handled;
			}
		}
	}

	return Plugin_Continue;
}